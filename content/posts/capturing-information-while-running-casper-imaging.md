---
title: 'Capturing information while running Casper Imaging'
date: Fri, 06 May 2016 20:09:40 +0000
draft: false
tags: ['Casper']
---

I recently changed jobs and am now managing a JAMF Casper suite that really hadn't had much done to it before. Previous imaging was done via a monolithic image with Clonezilla and a lot of hand configuration. The Windows environment here is much more mature and one of the things that is done on the Windows side is to capture information about the build as it happens. This post is about replicating that on the Macs when using Casper Imaging. Sidenote: I hope to move to DEP soon and stop most of the imaging that happens here, but until then... Our basic workflow is to boot from a flash drive created from an AutoCasperNBI image. From there Casper Imaging launches, is configured, and the process starts. The first thing in our configuration is a script that prompts for the builder's Tech ID, their AD password, the user ID for the person this computer is assigned to, which part of the business they are in, and what country this computer is going to. The script also records the start time and date of the build as well as the time zone offset (more on that later). This data is written to flat files stored in /tmp/tags/. Then the rest of the install happens, OS is block copied, application packages run, and a second script copies the output of the first script to the newly installed internal drive; /Volumes/Macintosh\\ HD/opt/wkstnctl/tags. This is the location that our BigFix install was looking for information from the cloned/hand configured systems. Then the client reboots and does the rest of the package installs and configuration that has to happen while booted to the "real" OS. The last thing that runs before the final reboot is a script to capture the time the build completes. This is where the time zone offset comes in. I can't rely on the client to have the right time zone at this point. I tried (with help - Thanks MacAdmin Slack) to trigger the system to adjust the time zone automatically, but couldn't make it automatic. So this is where the time zone offset comes into play. I have the original time zone offset and then get the current one and do the math to record completion time that matches the start time. Here is the first script (CaptureBuildInfo.sh) (priority 1): \[code language="bash"\] #!/bin/sh # Capture build info including start time, tech ID, and intended user ID mkdir -p /tmp/tag/ # Record start time and time zone offset echo &quot;$(date +&quot;%D %H:%M&quot;)&quot; &gt; /tmp/tag/BuildStarted.txt echo &quot;$(date +&quot;%z&quot;)&quot; &gt; /tmp/tag/TimeZoneOffset.txt # Some variable defaults for tests techName=&quot;&quot; techNameTest=&quot;false&quot; pwTest=&quot;kinit: Password incorrect&quot; pwCounter=0 endUser=&quot;&quot; endUserTest=&quot;false&quot; pwFileName=&quot;$(uuidgen).txt&quot; #Enter in the URL of the JSS we are are pulling info from. (NOTE: We will need https:// and :8443 (or whatever port you use). Example: https://jss.company.com:8443 ) jssURL=&quot;https://my.jss.tld:8443&quot; #URL for checking with AD adURL=$(host -t SRV \_ldap.\_tcp.my.domain.tld | head -n1 | cut -d&quot; &quot; -f 8 | sed -e 's/.$//') #Enter in a username and password that has the correct permissions to the JSS API for what data we need. Read Access to Accounts. jssUser=&quot;apiuser&quot; jssPass=&quot;apipassword!&quot; #Name for XML files pulled from JSS declare -x UserXML=&quot;/tmp/users.xml&quot; #Get list of users from JSS /usr/bin/curl -k -s -u &quot;$jssUser&quot;:&quot;$jssPass&quot; &quot;$jssURL&quot;/JSSResource/accounts -X GET -o &quot;$UserXML&quot; ######################################################################### # Collect and test Tech ID name against JSS imaging accounts # while the entered name all lower case doesn't equal the JSS based name all lower case while \[\[ $(echo &quot;$techName&quot; | tr \[:upper:\] \[:lower:\]) != $(echo &quot;$techNameTest&quot; | tr \[:upper:\] \[:lower:\]) \]\]; do techName=\`/usr/bin/osascript &lt;&lt;EOT tell application &quot;System Events&quot; with timeout of 43200 seconds activate set myReply to text returned of (display dialog &quot;Please enter your Tech ID (first.last):&quot; default answer &quot;&quot; buttons {&quot;Continue&quot;} default button &quot;Continue&quot;) end timeout end tell EOT\` # check if collected name is in the list pulled from the JSS # techNameTest will equal the name stored in the JSS if this succeeds # techNameTest will equal &quot;&quot; if this fails techNameTest=$(xmllint &quot;$UserXML&quot; --xpath &quot;/accounts/users/user/name&quot; | sed 's/&lt;name&gt;//g' | sed -e $'s/&lt;\\/name&gt;/\\\\\\n/g' | grep -i -m 1 -F &quot;$techName&quot;) done #write the Tech ID to our plist for collection later echo &quot;$techNameTest&quot; &gt; /tmp/tag/TechID.txt ######################################################################### # collect and test Tech password while \[ &quot;$pwTest&quot; == &quot;kinit: Password incorrect&quot; \] &amp;&amp; \[ $pwCounter -lt 2 \]; do techPW=\`/usr/bin/osascript &lt;&lt;EOT tell application &quot;SystemUIServer&quot; with timeout of 43200 seconds activate set myReply to text returned of (display dialog &quot;Please enter your Tech ID password:&quot; with hidden answer default answer &quot;&quot; buttons {&quot;Continue&quot;} default button &quot;Continue&quot;) end timeout end tell EOT\` # increment the counter so that we only try twice. Don't want to lock an account pwCounter=$\[$pwCounter+1\] # sadly, write the password out to a file for the next step echo &quot;$techPW&quot; &gt; /tmp/$pwFileName # Try to authenticate as the tech using the password file # pwTest will equal &quot;kinit: Password incorrect&quot; if the password is wrong. # pwTest will equal &quot;&quot; if the password is right pwTest=$(kinit --password-file=/tmp/$pwFileName &quot;${techNameTest}@AM.JLLNET.COM&quot; 2&gt;&amp;1 &gt;/dev/null) #OLD and insecure pwTest=$(ldapwhoami -vvv -h &quot;$adURL&quot; -D &quot;${techNameTest}@am.jllnet.com&quot; -x -w &quot;$techPW&quot; | grep Success) #securely erase the password file srm /tmp/$pwFileName done # If they have tried twice and still failed, bail out so as to not lock their account if \[ $pwCounter = 2 \] &amp;&amp; \[ &quot;$pwTest&quot; == &quot;kinit: Password incorrect&quot; \]; then /usr/bin/osascript &lt;&lt;EOT tell application &quot;SystemUIServer&quot; with timeout of 43200 seconds display dialog &quot;This script can not authenticate you and doesn't want to lock you out of your account. Please verify your password elsewhere and try again.&quot; default button &quot;Cancel&quot; end timeout end tell EOT exit 1 fi ######################################################################### # Collect and test end user id # while the typed name does not equal a name found in AD, keep asking while \[\[ $(echo &amp;quot;$endUserTest&amp;quot; | tr \[:upper:\] \[:lower:\]) != $(echo &amp;quot;$endUser&amp;quot; | tr \[:upper:\] \[:lower:\]) \]\]; do endUser=\`/usr/bin/osascript &amp;lt;&amp;lt;EOT tell application &amp;quot;SystemUIServer&amp;quot; with timeout of 43200 seconds activate set myReply to text returned of (display dialog &amp;quot;Please enter the end user's ID (first.last):&amp;quot; default answer &amp;quot;&amp;quot; buttons {&amp;quot;Continue&amp;quot;} default button &amp;quot;Continue&amp;quot;) end timeout end tell EOT\` # check collected name against AD # endUserTest should equal the proper user name from AD if this succeeds # endUserTest will equal &quot;&quot; if this fails #OLD and insecure endUserTest=$(ldapsearch -LLL -x -h &quot;$adURL&quot; -D &quot;${techNameTest}@am.jll.com&quot; -w &quot;$techPW&quot; -b &quot;dc=am,dc=jllnet,dc=com&quot; &quot;(&amp;(objectCategory=Person)(objectClass=User)(sAMAccountName=$endUser))&quot; sAMAccountName | grep sAMAccountName | cut -d&quot; &quot; -f 2) endUserTest=$(ldapsearch -LLL -H &quot;ldap://${adURL}&quot; -b &quot;dc=am,dc=jllnet,dc=com&quot; &quot;(&amp;(objectCategory=Person)(objectClass=User)(sAMAccountName=$endUser))&quot; sAMAccountName 2&gt;/dev/null | grep sAMAccountName | cut -d&quot; &quot; -f 2) done # write the end user info to the plist echo &quot;$endUserTest&quot; &gt; /tmp/tag/JLL\_SAM.txt echo &quot;${endUserTest}@am.jll.com&quot; &gt; /tmp/tag/JLL\_UserEmailID.txt echo &quot;${endUserTest}@am.jll.com&quot; &gt; /tmp/tag/JLL\_UserUPN.txt ######################################################################### # Collect the Business ID from a list businessID=\`/usr/bin/osascript &lt;&lt;EOT tell application &quot;SystemUIServer&quot; activate with timeout of 600 seconds set businessID to (choose from list {&quot;Unit 1&quot;, &quot;Unit 2&quot;, &quot;Unit 3&quot;} with prompt &quot;Choose the appropriate\\nbusiness unit:&quot; default items {&quot;Unit 1&quot;}) end timeout end tell EOT\` #store the business id echo &quot;$businessID&quot; &gt; /tmp/tag/BusinessID.txt ######################################################################### # Collect the Country ID from a list countryID=\`/usr/bin/osascript &lt;&lt;EOT tell application &quot;SystemUIServer&quot; activate with timeout of 600 seconds set businessID to (choose from list {&quot;US&quot;, &quot;CA&quot;, &quot;MX&quot;, &quot;SA&quot;} with prompt &quot;Choose the appropriate country:&quot; default items {&quot;US&quot;}) end timeout end tell EOT\` #store the country ID echo &quot;$countryID&quot; &gt; /tmp/tag/CountryID.txt #store build version number echo &quot;2.0.0&quot; &gt; /tmp/tag/BuildVersion.txt \[/code\] It starts by creating a "tag" directory in /tmp on the boot drive. Then it uses the date command to record the start time and date in the format my organization wants. Then the date command is used again to record the time zone offset with the %z formatting. I then set some default values for variables that will be part of tests later. I also create a unique filename for briefly storing a password later (this is not ideal, but you will see why later). Then I define my JSS address, look up a domain controller, and enter authentication information for a user with JSS API read access. Be sure to adjust these to match your environment. Next I pull a list of accounts from the JSS with the API user and store this in a file (also in /tmp). Now we are ready to prompt for the installers Tech ID. The first time through the test will fail as the two variables are set to not be the same. So then the osascript (AppleScript) will run and collect the users name. That value is used to compare (case insensitive) to the list of accounts on the JSS that was saved earlier. If these match, the test is matched and we move on. Otherwise, the osascript will run again and the installer can try again. Once this is successful, the Tech ID is saved to the tags. Next use a similar loop to check the tech's password. The osascript prompts for a password with a hidden answer. The password is stored in the unique file defined above. As the JSS is populated from our AD, I check the password against AD using kinit. If this is successful, we can break out of the loop and also get a Kerberos ticket granting ticket, which we will use in a bit. If the kinit fails, the tech gets one more chance. If they fail twice, we give up so as to not lock their AD account. Once the kinit has run, I securely remove the password file. At this point we have a valid AD user account that is also allowed on the JSS and that user has a TGT from AD. I then prompt for the ID of the end user this computer will go to. Using the tech's ID and TGT I securely query AD to confirm that the end user ID exists. Once this ldapsearch is successful, the loop exits and the account ID is written to tags for SAM, and then a built email and UPN. The script then prompts for the business unit and country this computer is going to. An osascript shows a list with our most common answer selected by default. These are then stored in tags to be used later for policies to customize the systems. Lastly, the image version is written to a tag. Later in the configuration, script two (CopyBuildInfo.sh) runs (priority 10). \[code language="bash"\] #!/bin/sh # This copies the organizational info from /tmp onto the newly imaged HD. # The info is captured when the image process is started and entered by the tech doing the imaging. if \[ -d /tmp/tag \]; then mkdir -p &quot;$1/opt/wkstnctl/&quot; cp -R /tmp/tag &quot;$1/opt/wkstnctl/&quot; fi \[/code\] This simply confirms that the tag directory exists as a directory and then makes the final destination and copies the tag directory to it. This uses the $1 variable available in Casper Imaging to reference the target volume. The system reboots and any packages that need to be installed while booted from the "real" OS run. Then lastly, our third script runs. This is named zBuildComplete.sh (so it is last) and is set to run on reboot. \[code language="bash"\] #!/bin/sh # Capture when build is complete timezoneoffset=$(cat /Volumes/Macintosh\\ HD/opt/wkstnctl/tag/TimeZoneOffset.txt) case &quot;$timezoneoffset&quot; in -0300) starttz=-3 ;; -0400) starttz=-4 ;; -0500) starttz=-5 ;; -600) starttz=-6 ;; -0700) starttz=-7 ;; -0800) starttz=-8 ;; -0900) starttz=-9 ;; -1000) starttz=-10 ;; esac currenttimezoneoffset=$(date +&quot;%z&quot;) case &quot;$currenttimezoneoffset&quot; in -0300) endtz=-3 ;; -0400) endtz=-4 ;; -0500) endtz=-5 ;; -600) endtz=-6 ;; -0700) endtz=-7 ;; -0800) endtz=-8 ;; -0900) endtz=-9 ;; -1000) endtz=-10 ;; sac difference=$(expr $starttz - $endtz) if \[ $difference -eq 0 \]; then completionDate=$(date +&quot;%D %H:%M&quot;) elif \[ $difference -gt 0 \]; then completionDate=$(date -v &quot;+${difference}H&quot; +&quot;%D %H:%M&quot;) else completionDate=$(date -v &quot;${difference}H&quot; +&quot;%D %H:%M&quot;) fi echo &quot;$completionDate&quot; &gt; /Volumes/Macintosh\\ HD/opt/wkstnctl/tag/BuildComplete.txt \[/code\] This one is a bit messy. First I read the offset stored from the start and use a case statement to convert it to an integer. Then get the current time zone offset and do the same. Now I can calculate the difference between the two. Then I use that difference to generate a build completion time based on the current time. The date command takes a -v option to adjust the time, but that option needs to have the sign of the change explicit. So there is an if statement to format it properly. If the difference is 0, don't use an adjustment, if the difference is positive, print + then the value, else print the value, which will include the - sign. Once that has all been sorted out, store the completion time in our tags.