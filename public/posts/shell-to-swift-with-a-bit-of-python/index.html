<!DOCTYPE html>
<html lang="en-us">
  <head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>Shell to Swift with a bit of Python | My Thoughts</title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="description" content="This is probably the first of a couple of posts about this project. There are a couple of things I learned I want to expand on, but don&rsquo;t want to make this too long. So this will be an overview of the project. For years I have had a shell script that collected some network info and it was displayed on my desktop using NerdTool and then GeekTool. While testing macOS Catalina betas, GeekTool hasn&rsquo;t been working for me. The other concern with these options is that they run the shell script on a schedule which can be much to frequent or not frequent enough.  So I rewrote it with Xcode in Swift. I have recently been doing more with Swift and was inspired by Macshome&rsquo;s workshop at PSU MacAdmin 2019. In that workshop he showed off a nice Swift function for running shell scripts (he planned to opensource the workshop code, so I will link to it when I can). He also demonstrated how to store functions in one file and reference them in another which made for much cleaner and transportable code. I started with that and reproduced my network info output and that was working well. At this point the program was a cli command. While it worked well in the terminal, I wanted to have the output available at a glance. I created a new Xcode project to create a GUI version. Because I had all my functions in a separate NetworkInfo.swift file, I was able to drag that into the GUI project and call them from there.  The main parts of the project now relied on ​​​networksetup to find all the network services and get the ip addresses of the active services and looked like this. Then I was further inspired by zakes and frogor in #python in the MacAdmin Slack to try to use more native calls instead of shell commands.  They were using PyObjC to call native macOS methods, so it was pretty straight forward to use them in Swift after a bit of reading the documentation. I also got some help from bp in #swift on getting nicer output from some of the methods. At this point, I could print all the output I wanted nicely, but only when the application is launched. I found NWPathMonitor in Apple&rsquo;s documentation and with some trial and error, I was able to get the function to update the UI whenever the network state on the Mac changed. By moving from shell calls to native methods, the code runs much faster.  Using time to compare the two commands, the ProcessRunner version runs in 1.155s while the native command version runs in .243s. Certainly not a huge deal for something this simple, but shows the benefit of using the native tools when possible. Another benefit is that by using a native wrapping label in a standard window, the network info is now selectable and copyable. In another post, I plan to describe the structure of the project and how it monitors for network changes.  I also hope to figure out how to use the macOS native controls to allow a user to adjust the fonts, colors, and opacity of the display.  Finally, I would like to include the cli command in the GUI bundle, so it can be called from Terminal if needed.">
    <meta name="generator" content="Hugo 0.135.0">
    
    
    
    
      <meta name="robots" content="noindex, nofollow">
    
    

    
<link rel="stylesheet" href="/ananke/css/main.min.css" >



    

    
      

    

    

    
      <link rel="canonical" href="http://localhost:1313/posts/shell-to-swift-with-a-bit-of-python/">
    

    <meta property="og:url" content="http://localhost:1313/posts/shell-to-swift-with-a-bit-of-python/">
  <meta property="og:site_name" content="My Thoughts">
  <meta property="og:title" content="Shell to Swift with a bit of Python">
  <meta property="og:description" content="This is probably the first of a couple of posts about this project. There are a couple of things I learned I want to expand on, but don’t want to make this too long. So this will be an overview of the project. For years I have had a shell script that collected some network info and it was displayed on my desktop using NerdTool and then GeekTool. While testing macOS Catalina betas, GeekTool hasn’t been working for me. The other concern with these options is that they run the shell script on a schedule which can be much to frequent or not frequent enough. So I rewrote it with Xcode in Swift. I have recently been doing more with Swift and was inspired by Macshome’s workshop at PSU MacAdmin 2019. In that workshop he showed off a nice Swift function for running shell scripts (he planned to opensource the workshop code, so I will link to it when I can). He also demonstrated how to store functions in one file and reference them in another which made for much cleaner and transportable code. I started with that and reproduced my network info output and that was working well. At this point the program was a cli command. While it worked well in the terminal, I wanted to have the output available at a glance. I created a new Xcode project to create a GUI version. Because I had all my functions in a separate NetworkInfo.swift file, I was able to drag that into the GUI project and call them from there. The main parts of the project now relied on ​​​networksetup to find all the network services and get the ip addresses of the active services and looked like this. Then I was further inspired by zakes and frogor in #python in the MacAdmin Slack to try to use more native calls instead of shell commands. They were using PyObjC to call native macOS methods, so it was pretty straight forward to use them in Swift after a bit of reading the documentation. I also got some help from bp in #swift on getting nicer output from some of the methods. At this point, I could print all the output I wanted nicely, but only when the application is launched. I found NWPathMonitor in Apple’s documentation and with some trial and error, I was able to get the function to update the UI whenever the network state on the Mac changed. By moving from shell calls to native methods, the code runs much faster. Using time to compare the two commands, the ProcessRunner version runs in 1.155s while the native command version runs in .243s. Certainly not a huge deal for something this simple, but shows the benefit of using the native tools when possible. Another benefit is that by using a native wrapping label in a standard window, the network info is now selectable and copyable. In another post, I plan to describe the structure of the project and how it monitors for network changes. I also hope to figure out how to use the macOS native controls to allow a user to adjust the fonts, colors, and opacity of the display. Finally, I would like to include the cli command in the GUI bundle, so it can be called from Terminal if needed.">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2019-07-29T16:13:56+00:00">
    <meta property="article:modified_time" content="2019-07-29T16:13:56+00:00">
    <meta property="article:tag" content="Swift">

  <meta itemprop="name" content="Shell to Swift with a bit of Python">
  <meta itemprop="description" content="This is probably the first of a couple of posts about this project. There are a couple of things I learned I want to expand on, but don’t want to make this too long. So this will be an overview of the project. For years I have had a shell script that collected some network info and it was displayed on my desktop using NerdTool and then GeekTool. While testing macOS Catalina betas, GeekTool hasn’t been working for me. The other concern with these options is that they run the shell script on a schedule which can be much to frequent or not frequent enough. So I rewrote it with Xcode in Swift. I have recently been doing more with Swift and was inspired by Macshome’s workshop at PSU MacAdmin 2019. In that workshop he showed off a nice Swift function for running shell scripts (he planned to opensource the workshop code, so I will link to it when I can). He also demonstrated how to store functions in one file and reference them in another which made for much cleaner and transportable code. I started with that and reproduced my network info output and that was working well. At this point the program was a cli command. While it worked well in the terminal, I wanted to have the output available at a glance. I created a new Xcode project to create a GUI version. Because I had all my functions in a separate NetworkInfo.swift file, I was able to drag that into the GUI project and call them from there. The main parts of the project now relied on ​​​networksetup to find all the network services and get the ip addresses of the active services and looked like this. Then I was further inspired by zakes and frogor in #python in the MacAdmin Slack to try to use more native calls instead of shell commands. They were using PyObjC to call native macOS methods, so it was pretty straight forward to use them in Swift after a bit of reading the documentation. I also got some help from bp in #swift on getting nicer output from some of the methods. At this point, I could print all the output I wanted nicely, but only when the application is launched. I found NWPathMonitor in Apple’s documentation and with some trial and error, I was able to get the function to update the UI whenever the network state on the Mac changed. By moving from shell calls to native methods, the code runs much faster. Using time to compare the two commands, the ProcessRunner version runs in 1.155s while the native command version runs in .243s. Certainly not a huge deal for something this simple, but shows the benefit of using the native tools when possible. Another benefit is that by using a native wrapping label in a standard window, the network info is now selectable and copyable. In another post, I plan to describe the structure of the project and how it monitors for network changes. I also hope to figure out how to use the macOS native controls to allow a user to adjust the fonts, colors, and opacity of the display. Finally, I would like to include the cli command in the GUI bundle, so it can be called from Terminal if needed.">
  <meta itemprop="datePublished" content="2019-07-29T16:13:56+00:00">
  <meta itemprop="dateModified" content="2019-07-29T16:13:56+00:00">
  <meta itemprop="wordCount" content="556">
  <meta itemprop="keywords" content="Swift">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Shell to Swift with a bit of Python">
  <meta name="twitter:description" content="This is probably the first of a couple of posts about this project. There are a couple of things I learned I want to expand on, but don’t want to make this too long. So this will be an overview of the project. For years I have had a shell script that collected some network info and it was displayed on my desktop using NerdTool and then GeekTool. While testing macOS Catalina betas, GeekTool hasn’t been working for me. The other concern with these options is that they run the shell script on a schedule which can be much to frequent or not frequent enough. So I rewrote it with Xcode in Swift. I have recently been doing more with Swift and was inspired by Macshome’s workshop at PSU MacAdmin 2019. In that workshop he showed off a nice Swift function for running shell scripts (he planned to opensource the workshop code, so I will link to it when I can). He also demonstrated how to store functions in one file and reference them in another which made for much cleaner and transportable code. I started with that and reproduced my network info output and that was working well. At this point the program was a cli command. While it worked well in the terminal, I wanted to have the output available at a glance. I created a new Xcode project to create a GUI version. Because I had all my functions in a separate NetworkInfo.swift file, I was able to drag that into the GUI project and call them from there. The main parts of the project now relied on ​​​networksetup to find all the network services and get the ip addresses of the active services and looked like this. Then I was further inspired by zakes and frogor in #python in the MacAdmin Slack to try to use more native calls instead of shell commands. They were using PyObjC to call native macOS methods, so it was pretty straight forward to use them in Swift after a bit of reading the documentation. I also got some help from bp in #swift on getting nicer output from some of the methods. At this point, I could print all the output I wanted nicely, but only when the application is launched. I found NWPathMonitor in Apple’s documentation and with some trial and error, I was able to get the function to update the UI whenever the network state on the Mac changed. By moving from shell calls to native methods, the code runs much faster. Using time to compare the two commands, the ProcessRunner version runs in 1.155s while the native command version runs in .243s. Certainly not a huge deal for something this simple, but shows the benefit of using the native tools when possible. Another benefit is that by using a native wrapping label in a standard window, the network info is now selectable and copyable. In another post, I plan to describe the structure of the project and how it monitors for network changes. I also hope to figure out how to use the macOS native controls to allow a user to adjust the fonts, colors, and opacity of the display. Finally, I would like to include the cli command in the GUI bundle, so it can be called from Terminal if needed.">

	
  </head>

  <body class="ma0 avenir bg-near-white">

    
   
  

  <header>
    <div class="bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="/" class="f3 fw2 hover-white no-underline white-90 dib">
      
        My Thoughts
      
    </a>
    <div class="flex-l items-center">
      

      
      
<div class="ananke-socials">
  
</div>

    </div>
  </div>
</nav>

    </div>
  </header>



    <main class="pb7" role="main">
      
  
  <article class="flex-l flex-wrap justify-between mw8 center ph3">
    <header class="mt4 w-100">
      <aside class="instapaper_ignoref b helvetica tracked ttu">
          
        Posts
      </aside>
      










  <div id="sharing" class="mt3 ananke-socials">
    
  </div>


      <h1 class="f1 athelas mt3 mb1">Shell to Swift with a bit of Python</h1>
      
      
      
      <time class="f6 mv4 dib tracked" datetime="2019-07-29T16:13:56Z">July 29, 2019</time>
      

      
      
    </header>
    <div class="nested-copy-line-height lh-copy serif f4 nested-links mid-gray pr4-l w-two-thirds-l"><p>This is probably the first of a couple of posts about this project. There are a couple of things I learned I want to expand on, but don&rsquo;t want to make this too long. So this will be an overview of the project. For years I have had a <a href="https://sneakypockets.wordpress.com/2015/05/05/update-to-network-geektool-script/">shell script</a> that collected some network info and it was displayed on my desktop using <a href="http://mutablecode.com/apps/nerdtool.html">NerdTool</a> and then <a href="https://www.tynsoe.org/v2/geektool/">GeekTool</a>. While testing macOS Catalina betas, GeekTool hasn&rsquo;t been working for me. The other concern with these options is that they run the shell script on a schedule which can be much to frequent or not frequent enough.  So I <a href="https://github.com/ehemmete/NetworkInfoGUI">rewrote it with Xcode in Swift</a>. I have <a href="https://sneakypockets.wordpress.com/2019/04/15/using-a-swift-app-to-get-rid-of-lots-of-applescript-dialogs/">recently been doing more with Swift</a> and was inspired by <a href="https://psumac2019.sched.com/event/KQo3/swift-xcode-an-app-and-you">Macshome&rsquo;s workshop at PSU MacAdmin 2019</a>. In that workshop he showed off a nice Swift function for running shell scripts (he planned to opensource the workshop code, so I will link to it when I can). He also demonstrated how to store functions in one file and reference them in another which made for much cleaner and transportable code. I started with that and reproduced my network info output and that was working well. At this point the program was a cli command. <img src="https://sneakypockets.wordpress.com/wp-content/uploads/2019/07/screen-shot-2019-07-26-at-8.38.25-pm-1.png" alt="Screen Shot 2019-07-26 at 8.38.25 PM.png">While it worked well in the terminal, I wanted to have the output available at a glance. I created a new Xcode project to create a GUI version. Because I had all my functions in a separate NetworkInfo.swift file, I was able to drag that into the GUI project and call them from there.  The main parts of the project now relied on ​​<code>​networksetup</code> to find all the network services and get the ip addresses of the active services and <a href="https://github.com/ehemmete/NetworkInfoGUI/blob/master/NetworkFunctions(shell-based).swift">looked like this</a>. Then I was further inspired by <a href="https://macadmins.slack.com/archives/C056UTQ3M/p1563909962029100">zakes</a> and <a href="https://macadmins.slack.com/archives/C056UTQ3M/p1563914551039800">frogor</a> in #python in the <a href="http://macadmins.org">MacAdmin Slack</a> to try to use more native calls instead of shell commands.  They were using PyObjC to call native macOS methods, so it was pretty straight forward to use them in Swift after a bit of reading the documentation. I also got some help from <a href="https://macadmins.slack.com/archives/C0688BNEM/p1563637834003600">bp</a> in #swift on getting nicer output from some of the methods. At this point, I could print all the output I wanted nicely, but only when the application is launched. I found <a href="https://developer.apple.com/documentation/network/nwpathmonitor">NWPathMonitor in Apple&rsquo;s documentation</a> and with some trial and error, I was able to get the function to update the UI whenever the network state on the Mac changed.<img src="https://sneakypockets.wordpress.com/wp-content/uploads/2019/07/screen-shot-2019-07-26-at-8.56.45-pm.png" alt="Screen Shot 2019-07-26 at 8.56.45 PM.png"> By moving from shell calls to native methods, the code runs much faster.  Using <code>time</code> to compare the two commands, the ProcessRunner version runs in 1.155s while the native command version runs in .243s. Certainly not a huge deal for something this simple, but shows the benefit of using the native tools when possible. Another benefit is that by using a native wrapping label in a standard window, the network info is now selectable and copyable. In another post, I plan to describe the structure of the project and how it monitors for network changes.  I also hope to figure out how to use the macOS native controls to allow a user to adjust the fonts, colors, and opacity of the display.  Finally, I would like to include the cli command in the GUI bundle, so it can be called from Terminal if needed.</p>
<ul class="pa0">
  
   <li class="list di">
     <a href="/tags/swift/" class="link f5 grow no-underline br-pill ba ph3 pv2 mb2 dib black sans-serif">Swift</a>
   </li>
  
</ul>
<div class="mt6 instapaper_ignoref">
      
      
      </div>
    </div>

    <aside class="w-30-l mt6-l">




  <div class="bg-light-gray pa3 nested-list-reset nested-copy-line-height nested-links">
    <p class="f5 b mb3">Related</p>
    <ul class="pa0 list">
	   
	     <li  class="mb2">
          <a href="/posts/using-a-swift-app-to-get-rid-of-lots-of-applescript-dialogs/">Using a Swift app to get rid of lots of AppleScript dialogs</a>
        </li>
	    
    </ul>
</div>

</aside>

  </article>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="http://localhost:1313/" >
    &copy;  Eric Hemmeter 2024 
  </a>
    <div>
<div class="ananke-socials">
  
</div>
</div>
  </div>
</footer>

  </body>
</html>
