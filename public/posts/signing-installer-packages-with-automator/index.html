<!DOCTYPE html>
<html lang="en-us">
  <head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>Signing Installer Packages with Automator | My Thoughts</title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="description" content="Apple packages (.pkgs) are opened by the GUI Installer.app or the command line installer command. If a package is unsigned and gets a quarantine flag (from being transferred over a network), the GUI Installer will refuse to run it. We can get around that with a right-click -&gt; Open, but we shouldn&rsquo;t be training computer users to ignore security warnings like this.  If you are creating your own packages, and users or techs may run them manually, then you really should be signing them. Even if you are deploying them in a way that a person won&rsquo;t see a warning, signing packages can be very easy and provide a check that nothing changed since you created it. See below the break for how to easily automate signing packages. I use WhiteBox Packages to create most of my packages. It has a built in feature to sign packages it builds, but recent versions have had some problems with it and when it works it still has to be set per package project. The Apple provided tool to sign our packages is productsign. This works, but to make things easier on myself, I have wrapped that up in an Automator application that I can use as a droplet. The basic format for using productsign is productsign [options] --sign identity input-product-path output-product-path Interestingly, the man page for productsign doesn&rsquo;t show any available options. So next we want to --sign using identity. This is our Developer ID Installer certificate from Apple&rsquo;s developer program. This does require a paid membership, but if you work for an organization supporting Macs, there is plenty of benefit to offset the $99 or $399/year (signing identities, early access to OS builds for testing, etc). To sign packages we need a Developer ID Installer (see Apple&rsquo;s documentation) Once you have your Dev ID Installer certificate installed in your keychain, then we can get the appropriate reference for it. Open /Applications/Utilities/Keychain Access. Search for Developer ID and select the appropriate certificate. Then you can highlight and copy the name.  If you are a part of more than one developer program, select the &ldquo;right&rdquo; one here.  You can create several Automator applications if you want to have one for each ID. So now we can write our command productsign --sign &#39;Developer ID Installer: OrgName (Code)&#39; in_pkg out_pkg. For example productsign --sign &#39;Developer ID Installer: OrgName (Code)&#39; ~/Development/Unsigned.pkg ~/Development/Signed.pkg. This will prompt to allow productsign access to your keychain. Say Allow or Always Allow.$ productsign --sign &#39;Developer ID Installer: OrgName (Code)&#39; ~/Desktop/Unsigned/build/Unsigned.pkg ~/Desktop/Unsigned/build/Signed.pkg productsign: using timestamp authority for signature productsign: signing product with identity &quot;Developer ID Installer: OrgName (Code)&quot; from keychain /Users/username/Library/Keychains/login.keychain-db productsign: adding certificate &quot;Developer ID Certification Authority&quot; productsign: adding certificate &quot;Apple Root CA&quot; productsign: Wrote signed product archive to /Users/username/Desktop/Unsigned/build/Signed.pkgNow when we run the installer by double clicking it, the installer opens. Notice the lock in the upper right corner. Click the clock and we can examine the certificate chain back to Apple&rsquo;s Root. The idea when we started was to make this easy to do since we might need to sign a lot of packages over time. To automate this, open /Applications/Automator.app. Choose to create a New Document. Then choose Application for the type and click Choose. Search for shell in the Actions name search field. Drag a run shell script action to the workflow. First adjust the Pass input: pop up to as arguments. That will fill in the template for us. Then enter our productsign command with some slight differences. The --sign and identity will be the same, but now for the input and output, we need to make this work with whatever is dropped on the application. The packages will be passed as arguments and the for loop will work on each one in turn. These will be assigned to the pkg variable, so that becomes our input file. Then for the output, I settled on packagename.signed.pkg to differentiate the output from the input. This $(sed &#39;s/.pkg$/.signed.pkg/g&#39; &lt;&lt;&lt; $pkg) will find the last &lsquo;.pkg&rsquo; in the filename and replace it with &lsquo;.signed.pkg&rsquo;, while keeping the name portion the same (see note at the end for how this works) .  Notice I also changed the f to pkg just to make it clear what the variable represents.```
for pkg in &ldquo;$@&rdquo;
do
productsign &ndash;sign &lsquo;Developer ID Installer: OrgName (Code)&rsquo; &ldquo;$pkg&rdquo; &ldquo;$(sed &rsquo;s/.pkg$/.signed.pkg/g&rsquo; &laquo;&lt; $pkg)&rdquo;
done">
    <meta name="generator" content="Hugo 0.135.0">
    
    
    
    
      <meta name="robots" content="noindex, nofollow">
    
    

    
<link rel="stylesheet" href="/ananke/css/main.min.css" >



    

    
      

    

    

    
      <link rel="canonical" href="http://localhost:1313/posts/signing-installer-packages-with-automator/">
    

    <meta property="og:url" content="http://localhost:1313/posts/signing-installer-packages-with-automator/">
  <meta property="og:site_name" content="My Thoughts">
  <meta property="og:title" content="Signing Installer Packages with Automator">
  <meta property="og:description" content="Apple packages (.pkgs) are opened by the GUI Installer.app or the command line installer command. If a package is unsigned and gets a quarantine flag (from being transferred over a network), the GUI Installer will refuse to run it. We can get around that with a right-click -&gt; Open, but we shouldn’t be training computer users to ignore security warnings like this. If you are creating your own packages, and users or techs may run them manually, then you really should be signing them. Even if you are deploying them in a way that a person won’t see a warning, signing packages can be very easy and provide a check that nothing changed since you created it. See below the break for how to easily automate signing packages. I use WhiteBox Packages to create most of my packages. It has a built in feature to sign packages it builds, but recent versions have had some problems with it and when it works it still has to be set per package project. The Apple provided tool to sign our packages is productsign. This works, but to make things easier on myself, I have wrapped that up in an Automator application that I can use as a droplet. The basic format for using productsign is productsign [options] --sign identity input-product-path output-product-path Interestingly, the man page for productsign doesn’t show any available options. So next we want to --sign using identity. This is our Developer ID Installer certificate from Apple’s developer program. This does require a paid membership, but if you work for an organization supporting Macs, there is plenty of benefit to offset the $99 or $399/year (signing identities, early access to OS builds for testing, etc). To sign packages we need a Developer ID Installer (see Apple’s documentation) Once you have your Dev ID Installer certificate installed in your keychain, then we can get the appropriate reference for it. Open /Applications/Utilities/Keychain Access. Search for Developer ID and select the appropriate certificate. Then you can highlight and copy the name. If you are a part of more than one developer program, select the “right” one here. You can create several Automator applications if you want to have one for each ID. So now we can write our command productsign --sign &#39;Developer ID Installer: OrgName (Code)&#39; in_pkg out_pkg. For example productsign --sign &#39;Developer ID Installer: OrgName (Code)&#39; ~/Development/Unsigned.pkg ~/Development/Signed.pkg. This will prompt to allow productsign access to your keychain. Say Allow or Always Allow.$ productsign --sign &#39;Developer ID Installer: OrgName (Code)&#39; ~/Desktop/Unsigned/build/Unsigned.pkg ~/Desktop/Unsigned/build/Signed.pkg productsign: using timestamp authority for signature productsign: signing product with identity &#34;Developer ID Installer: OrgName (Code)&#34; from keychain /Users/username/Library/Keychains/login.keychain-db productsign: adding certificate &#34;Developer ID Certification Authority&#34; productsign: adding certificate &#34;Apple Root CA&#34; productsign: Wrote signed product archive to /Users/username/Desktop/Unsigned/build/Signed.pkgNow when we run the installer by double clicking it, the installer opens. Notice the lock in the upper right corner. Click the clock and we can examine the certificate chain back to Apple’s Root. The idea when we started was to make this easy to do since we might need to sign a lot of packages over time. To automate this, open /Applications/Automator.app. Choose to create a New Document. Then choose Application for the type and click Choose. Search for shell in the Actions name search field. Drag a run shell script action to the workflow. First adjust the Pass input: pop up to as arguments. That will fill in the template for us. Then enter our productsign command with some slight differences. The --sign and identity will be the same, but now for the input and output, we need to make this work with whatever is dropped on the application. The packages will be passed as arguments and the for loop will work on each one in turn. These will be assigned to the pkg variable, so that becomes our input file. Then for the output, I settled on packagename.signed.pkg to differentiate the output from the input. This $(sed &#39;s/.pkg$/.signed.pkg/g&#39; &lt;&lt;&lt; $pkg) will find the last ‘.pkg’ in the filename and replace it with ‘.signed.pkg’, while keeping the name portion the same (see note at the end for how this works) . Notice I also changed the f to pkg just to make it clear what the variable represents.``` for pkg in “$@” do productsign –sign ‘Developer ID Installer: OrgName (Code)’ “$pkg” “$(sed ’s/.pkg$/.signed.pkg/g’ «&lt; $pkg)” done">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2016-11-05T01:51:33+00:00">
    <meta property="article:modified_time" content="2016-11-05T01:51:33+00:00">
    <meta property="article:tag" content="Automator">
    <meta property="article:tag" content="OS X General">
    <meta property="article:tag" content="Shell Script">

  <meta itemprop="name" content="Signing Installer Packages with Automator">
  <meta itemprop="description" content="Apple packages (.pkgs) are opened by the GUI Installer.app or the command line installer command. If a package is unsigned and gets a quarantine flag (from being transferred over a network), the GUI Installer will refuse to run it. We can get around that with a right-click -&gt; Open, but we shouldn’t be training computer users to ignore security warnings like this. If you are creating your own packages, and users or techs may run them manually, then you really should be signing them. Even if you are deploying them in a way that a person won’t see a warning, signing packages can be very easy and provide a check that nothing changed since you created it. See below the break for how to easily automate signing packages. I use WhiteBox Packages to create most of my packages. It has a built in feature to sign packages it builds, but recent versions have had some problems with it and when it works it still has to be set per package project. The Apple provided tool to sign our packages is productsign. This works, but to make things easier on myself, I have wrapped that up in an Automator application that I can use as a droplet. The basic format for using productsign is productsign [options] --sign identity input-product-path output-product-path Interestingly, the man page for productsign doesn’t show any available options. So next we want to --sign using identity. This is our Developer ID Installer certificate from Apple’s developer program. This does require a paid membership, but if you work for an organization supporting Macs, there is plenty of benefit to offset the $99 or $399/year (signing identities, early access to OS builds for testing, etc). To sign packages we need a Developer ID Installer (see Apple’s documentation) Once you have your Dev ID Installer certificate installed in your keychain, then we can get the appropriate reference for it. Open /Applications/Utilities/Keychain Access. Search for Developer ID and select the appropriate certificate. Then you can highlight and copy the name. If you are a part of more than one developer program, select the “right” one here. You can create several Automator applications if you want to have one for each ID. So now we can write our command productsign --sign &#39;Developer ID Installer: OrgName (Code)&#39; in_pkg out_pkg. For example productsign --sign &#39;Developer ID Installer: OrgName (Code)&#39; ~/Development/Unsigned.pkg ~/Development/Signed.pkg. This will prompt to allow productsign access to your keychain. Say Allow or Always Allow.$ productsign --sign &#39;Developer ID Installer: OrgName (Code)&#39; ~/Desktop/Unsigned/build/Unsigned.pkg ~/Desktop/Unsigned/build/Signed.pkg productsign: using timestamp authority for signature productsign: signing product with identity &#34;Developer ID Installer: OrgName (Code)&#34; from keychain /Users/username/Library/Keychains/login.keychain-db productsign: adding certificate &#34;Developer ID Certification Authority&#34; productsign: adding certificate &#34;Apple Root CA&#34; productsign: Wrote signed product archive to /Users/username/Desktop/Unsigned/build/Signed.pkgNow when we run the installer by double clicking it, the installer opens. Notice the lock in the upper right corner. Click the clock and we can examine the certificate chain back to Apple’s Root. The idea when we started was to make this easy to do since we might need to sign a lot of packages over time. To automate this, open /Applications/Automator.app. Choose to create a New Document. Then choose Application for the type and click Choose. Search for shell in the Actions name search field. Drag a run shell script action to the workflow. First adjust the Pass input: pop up to as arguments. That will fill in the template for us. Then enter our productsign command with some slight differences. The --sign and identity will be the same, but now for the input and output, we need to make this work with whatever is dropped on the application. The packages will be passed as arguments and the for loop will work on each one in turn. These will be assigned to the pkg variable, so that becomes our input file. Then for the output, I settled on packagename.signed.pkg to differentiate the output from the input. This $(sed &#39;s/.pkg$/.signed.pkg/g&#39; &lt;&lt;&lt; $pkg) will find the last ‘.pkg’ in the filename and replace it with ‘.signed.pkg’, while keeping the name portion the same (see note at the end for how this works) . Notice I also changed the f to pkg just to make it clear what the variable represents.``` for pkg in “$@” do productsign –sign ‘Developer ID Installer: OrgName (Code)’ “$pkg” “$(sed ’s/.pkg$/.signed.pkg/g’ «&lt; $pkg)” done">
  <meta itemprop="datePublished" content="2016-11-05T01:51:33+00:00">
  <meta itemprop="dateModified" content="2016-11-05T01:51:33+00:00">
  <meta itemprop="wordCount" content="818">
  <meta itemprop="keywords" content="Automator,OS X General,Shell Script">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Signing Installer Packages with Automator">
  <meta name="twitter:description" content="Apple packages (.pkgs) are opened by the GUI Installer.app or the command line installer command. If a package is unsigned and gets a quarantine flag (from being transferred over a network), the GUI Installer will refuse to run it. We can get around that with a right-click -&gt; Open, but we shouldn’t be training computer users to ignore security warnings like this. If you are creating your own packages, and users or techs may run them manually, then you really should be signing them. Even if you are deploying them in a way that a person won’t see a warning, signing packages can be very easy and provide a check that nothing changed since you created it. See below the break for how to easily automate signing packages. I use WhiteBox Packages to create most of my packages. It has a built in feature to sign packages it builds, but recent versions have had some problems with it and when it works it still has to be set per package project. The Apple provided tool to sign our packages is productsign. This works, but to make things easier on myself, I have wrapped that up in an Automator application that I can use as a droplet. The basic format for using productsign is productsign [options] --sign identity input-product-path output-product-path Interestingly, the man page for productsign doesn’t show any available options. So next we want to --sign using identity. This is our Developer ID Installer certificate from Apple’s developer program. This does require a paid membership, but if you work for an organization supporting Macs, there is plenty of benefit to offset the $99 or $399/year (signing identities, early access to OS builds for testing, etc). To sign packages we need a Developer ID Installer (see Apple’s documentation) Once you have your Dev ID Installer certificate installed in your keychain, then we can get the appropriate reference for it. Open /Applications/Utilities/Keychain Access. Search for Developer ID and select the appropriate certificate. Then you can highlight and copy the name. If you are a part of more than one developer program, select the “right” one here. You can create several Automator applications if you want to have one for each ID. So now we can write our command productsign --sign &#39;Developer ID Installer: OrgName (Code)&#39; in_pkg out_pkg. For example productsign --sign &#39;Developer ID Installer: OrgName (Code)&#39; ~/Development/Unsigned.pkg ~/Development/Signed.pkg. This will prompt to allow productsign access to your keychain. Say Allow or Always Allow.$ productsign --sign &#39;Developer ID Installer: OrgName (Code)&#39; ~/Desktop/Unsigned/build/Unsigned.pkg ~/Desktop/Unsigned/build/Signed.pkg productsign: using timestamp authority for signature productsign: signing product with identity &#34;Developer ID Installer: OrgName (Code)&#34; from keychain /Users/username/Library/Keychains/login.keychain-db productsign: adding certificate &#34;Developer ID Certification Authority&#34; productsign: adding certificate &#34;Apple Root CA&#34; productsign: Wrote signed product archive to /Users/username/Desktop/Unsigned/build/Signed.pkgNow when we run the installer by double clicking it, the installer opens. Notice the lock in the upper right corner. Click the clock and we can examine the certificate chain back to Apple’s Root. The idea when we started was to make this easy to do since we might need to sign a lot of packages over time. To automate this, open /Applications/Automator.app. Choose to create a New Document. Then choose Application for the type and click Choose. Search for shell in the Actions name search field. Drag a run shell script action to the workflow. First adjust the Pass input: pop up to as arguments. That will fill in the template for us. Then enter our productsign command with some slight differences. The --sign and identity will be the same, but now for the input and output, we need to make this work with whatever is dropped on the application. The packages will be passed as arguments and the for loop will work on each one in turn. These will be assigned to the pkg variable, so that becomes our input file. Then for the output, I settled on packagename.signed.pkg to differentiate the output from the input. This $(sed &#39;s/.pkg$/.signed.pkg/g&#39; &lt;&lt;&lt; $pkg) will find the last ‘.pkg’ in the filename and replace it with ‘.signed.pkg’, while keeping the name portion the same (see note at the end for how this works) . Notice I also changed the f to pkg just to make it clear what the variable represents.``` for pkg in “$@” do productsign –sign ‘Developer ID Installer: OrgName (Code)’ “$pkg” “$(sed ’s/.pkg$/.signed.pkg/g’ «&lt; $pkg)” done">

	
  </head>

  <body class="ma0 avenir bg-near-white">

    
   
  

  <header>
    <div class="bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="/" class="f3 fw2 hover-white no-underline white-90 dib">
      
        My Thoughts
      
    </a>
    <div class="flex-l items-center">
      

      
      
<div class="ananke-socials">
  
</div>

    </div>
  </div>
</nav>

    </div>
  </header>



    <main class="pb7" role="main">
      
  
  <article class="flex-l flex-wrap justify-between mw8 center ph3">
    <header class="mt4 w-100">
      <aside class="instapaper_ignoref b helvetica tracked ttu">
          
        Posts
      </aside>
      










  <div id="sharing" class="mt3 ananke-socials">
    
  </div>


      <h1 class="f1 athelas mt3 mb1">Signing Installer Packages with Automator</h1>
      
      
      
      <time class="f6 mv4 dib tracked" datetime="2016-11-05T01:51:33Z">November 5, 2016</time>
      

      
      
    </header>
    <div class="nested-copy-line-height lh-copy serif f4 nested-links mid-gray pr4-l w-two-thirds-l"><p>Apple packages (.pkgs) are opened by the GUI Installer.app or the command line installer command. If a package is unsigned and gets a quarantine flag (from being transferred over a network), the GUI Installer will refuse to run it.<img src="https://sneakypockets.wordpress.com/wp-content/uploads/2016/11/screen-shot-2016-11-02-at-3-07-35-pm.png" alt="Screen Shot 2016-11-02 at 3.07.35 PM.png"> We can get around that with a right-click -&gt; Open, but we shouldn&rsquo;t be training computer users to ignore security warnings like this. <img src="https://sneakypockets.wordpress.com/wp-content/uploads/2016/11/screen-shot-2016-11-04-at-4-49-33-pm.png" alt="Screen Shot 2016-11-04 at 4.49.33 PM.png"> If you are creating your own packages, and users or techs may run them manually, then you really should be signing them. Even if you are deploying them in a way that a person won&rsquo;t see a warning, signing packages can be very easy and provide a check that nothing changed since you created it. See below the break for how to easily automate signing packages. I use <a href="http://s.sudre.free.fr/Software/Packages/about.html">WhiteBox Packages</a> to create most of my packages. It has a built in feature to sign packages it builds, but recent versions have had some problems with it and when it works it still has to be set per package project. The Apple provided tool to sign our packages is <code>productsign</code>. This works, but to make things easier on myself, I have wrapped that up in an Automator application that I can use as a droplet. The basic format for using productsign is <code>productsign [options] --sign identity input-product-path output-product-path</code> Interestingly, the man page for productsign doesn&rsquo;t show any available options. So next we want to <code>--sign</code> using <code>identity</code>. This is our Developer ID Installer certificate from Apple&rsquo;s developer program. This does require a paid membership, but if you work for an organization supporting Macs, there is plenty of benefit to offset the $99 or $399/year (signing identities, early access to OS builds for testing, etc). To sign packages we need a Developer ID Installer (see <a href="https://developer.apple.com/library/content/documentation/IDEs/Conceptual/AppDistributionGuide/MaintainingCertificates/MaintainingCertificates.html#//apple_ref/doc/uid/TP40012582-CH31-SW6">Apple&rsquo;s documentation</a>) Once you have your Dev ID Installer certificate installed in your keychain, then we can get the appropriate reference for it. Open /Applications/Utilities/Keychain Access. Search for Developer ID and select the appropriate certificate. Then you can highlight and copy the name.  If you are a part of more than one developer program, select the &ldquo;right&rdquo; one here.  You can create several Automator applications if you want to have one for each ID.<img src="https://sneakypockets.wordpress.com/wp-content/uploads/2016/11/screen-shot-2016-11-02-at-3-25-14-pm.png" alt="Screen Shot 2016-11-02 at 3.25.14 PM.png"> So now we can write our command <code>productsign --sign 'Developer ID Installer: OrgName (Code)' in_pkg out_pkg</code>. For example <code>productsign --sign 'Developer ID Installer: OrgName (Code)' ~/Development/Unsigned.pkg ~/Development/Signed.pkg</code>. This will prompt to allow productsign access to your keychain. Say Allow or Always Allow.<code>$ productsign --sign 'Developer ID Installer: OrgName (Code)' ~/Desktop/Unsigned/build/Unsigned.pkg ~/Desktop/Unsigned/build/Signed.pkg productsign: using timestamp authority for signature productsign: signing product with identity &quot;Developer ID Installer: OrgName (Code)&quot; from keychain /Users/username/Library/Keychains/login.keychain-db productsign: adding certificate &quot;Developer ID Certification Authority&quot; productsign: adding certificate &quot;Apple Root CA&quot; productsign: Wrote signed product archive to /Users/username/Desktop/Unsigned/build/Signed.pkg</code>Now when we run the installer by double clicking it, the installer opens. Notice the lock in the upper right corner. Click the clock and we can examine the certificate chain back to Apple&rsquo;s Root.<img src="https://sneakypockets.wordpress.com/wp-content/uploads/2016/11/screen-shot-2016-11-02-at-3-29-14-pm1.png" alt="Screen Shot 2016-11-02 at 3.29.14 PM.png"> The idea when we started was to make this easy to do since we might need to sign a lot of packages over time. To automate this, open /Applications/Automator.app. Choose to create a New Document. Then choose Application for the type and click Choose.<img src="https://sneakypockets.wordpress.com/wp-content/uploads/2016/11/screen-shot-2016-11-02-at-3-31-43-pm.png" alt="Screen Shot 2016-11-02 at 3.31.43 PM.png"> Search for shell in the Actions name search field. Drag a run shell script action to the workflow.<img src="https://sneakypockets.wordpress.com/wp-content/uploads/2016/11/screen-shot-2016-11-02-at-3-32-11-pm.png" alt="Screen Shot 2016-11-02 at 3.32.11 PM.png"> First adjust the Pass input: pop up to as arguments.<img src="https://sneakypockets.wordpress.com/wp-content/uploads/2016/11/screen-shot-2016-11-02-at-3-33-00-pm.png" alt="Screen Shot 2016-11-02 at 3.33.00 PM.png"> That will fill in the template for us. Then enter our productsign command with some slight differences. The <code>--sign</code> and <code>identity</code> will be the same, but now for the input and output, we need to make this work with whatever is dropped on the application. The packages will be passed as arguments and the for loop will work on each one in turn. These will be assigned to the pkg variable, so that becomes our input file. Then for the output, I settled on packagename.signed.pkg to differentiate the output from the input. This <code>$(sed 's/.pkg$/.signed.pkg/g' &lt;&lt;&lt; $pkg)</code> will find the last &lsquo;.pkg&rsquo; in the filename and replace it with &lsquo;.signed.pkg&rsquo;, while keeping the name portion the same (see note at the end for how this works) .  Notice I also changed the <code>f</code> to <code>pkg</code> just to make it clear what the variable represents.```
for pkg in &ldquo;$@&rdquo;
do
productsign &ndash;sign &lsquo;Developer ID Installer: OrgName (Code)&rsquo; &ldquo;$pkg&rdquo; &ldquo;$(sed &rsquo;s/.pkg$/.signed.pkg/g&rsquo; &laquo;&lt; $pkg)&rdquo;
done</p>
<pre tabindex="0"><code class="language-The" data-lang="The">
* * *

\* sed note - `$(sed &#39;s/.pkg$/.signed.pkg/g&#39; &lt;&lt;&lt; $pkg)` This sed command will search the string passed to it ($pkg in this case) for &#39;.pkg&#39;.  The $ means that the string must end with that &#39;.pkg&#39;. Once found, the &#39;.pkg&#39; will be replaced by &#39;.signed.pkg&#39; without changing anything else in the string.  Since this is the output file name, we taking in name.pkg and outputting name.signed.pkg.  The &lt;&lt;&lt; is a redirect to make sed work on the variable $pkg which is the package currently passed into the for loop.
</code></pre><ul class="pa0">
  
   <li class="list di">
     <a href="/tags/automator/" class="link f5 grow no-underline br-pill ba ph3 pv2 mb2 dib black sans-serif">Automator</a>
   </li>
  
   <li class="list di">
     <a href="/tags/os-x-general/" class="link f5 grow no-underline br-pill ba ph3 pv2 mb2 dib black sans-serif">OS X General</a>
   </li>
  
   <li class="list di">
     <a href="/tags/shell-script/" class="link f5 grow no-underline br-pill ba ph3 pv2 mb2 dib black sans-serif">Shell Script</a>
   </li>
  
</ul>
<div class="mt6 instapaper_ignoref">
      
      
      </div>
    </div>

    <aside class="w-30-l mt6-l">




  <div class="bg-light-gray pa3 nested-list-reset nested-copy-line-height nested-links">
    <p class="f5 b mb3">Related</p>
    <ul class="pa0 list">
	   
	     <li  class="mb2">
          <a href="/posts/mounting-file-shares-based-on-ad-group-membership-using-enterprise-connect/">Mounting File Shares Based on AD Group Membership using Enterprise Connect</a>
        </li>
	    
	     <li  class="mb2">
          <a href="/posts/using-ldapsearch-to-get-ad-data/">Using ldapsearch to get AD data</a>
        </li>
	    
	     <li  class="mb2">
          <a href="/posts/update-to-network-geektool-script/">Update to network GeekTool script</a>
        </li>
	    
	     <li  class="mb2">
          <a href="/posts/find-the-most-common-user-on-a-system/">Find the most common user on a system</a>
        </li>
	    
	     <li  class="mb2">
          <a href="/posts/macos-sierra-recovery-hd-changes/">macOS Sierra Recovery HD Changes</a>
        </li>
	    
	     <li  class="mb2">
          <a href="/posts/unhide-users-in-10-9-3/">Unhide /Users in 10.9.3</a>
        </li>
	    
	     <li  class="mb2">
          <a href="/posts/keyboard-shortcut-for-system-preferences/">Keyboard shortcut for System Preferences</a>
        </li>
	    
	     <li  class="mb2">
          <a href="/posts/control-if-a-window-opens-when-a-volume-mounts/">Control if a window opens when a volume mounts</a>
        </li>
	    
	     <li  class="mb2">
          <a href="/posts/get-the-path-of-file-onto-the-clipboard/">Get the path of file onto the clipboard</a>
        </li>
	    
    </ul>
</div>

</aside>

  </article>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="http://localhost:1313/" >
    &copy;  Eric Hemmeter 2024 
  </a>
    <div>
<div class="ananke-socials">
  
</div>
</div>
  </div>
</footer>

  </body>
</html>
